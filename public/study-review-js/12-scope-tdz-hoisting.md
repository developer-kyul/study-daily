✨2026-01-08 목요일

# 변수의 범위과 안전 수칙

JavaScript에서 변수를 잘 다루려면 변수가 **어디까지 영향을 미치는지(Scope)**,
그리고 **언제부터 사용할 수 있는지(TDZ)**를 정확히 알아야 합니다.

- **범위** : Scope
- **일시적 사각지대** : TDZ (Temporal Dead Zone)

마치 아파트 단지에서 각 세대가 어디까지 출입할 수 있는지,
언제부터 입주할 수 있는지를 아는 것과 같습니다.

---

# 스코프 (Scope)

스코프(scope)는 '범위'라는 뜻으로, 프로그래밍에서는 "변수에 접근할 수 있는 유효 범위"를 말합니다.

### **전역 (Global Scope)**

코드의 가장 바깥 영역에 선언되어 어디서든 부를 수 있는 범위입니다.
마치, 마을 광장에 세워진 공용 게시판과 같습니다.

### **지역 (Local Scope)**

특정 함수나 블록(`{}`) 내부에서만 변수가 살아있는 범위입니다.
마치, 우리 집 안의 개인용 달력과 같습니다.

- **함수 스코프** : 함수 내부에서 선언된 변수 (`let`, `const`, `var` 모두 적용)
- **블록 스코프** : 중괄호(`{}`) 내부에서 선언된 변수 (`let`과 `const`는 적용, `var`는 제외)

### 스코프 규칙

안쪽 구역에서는 바깥쪽 구역의 변수를 볼 수 있지만, 바깥쪽에서는 안쪽 구역의 변수를 들여다볼 수 없습니다. 마치, 집 안에서는 마당(전역)을 볼 수 있지만 길 가던 사람이 우리 집 안(지역)을 볼 수 없는 것과 같습니다.

```jsx
let garden = '마당의 꽃'; // 전역 변수

function myHouse() {
  let desk = '책상 위의 노트북'; // 지역 변수

  console.log(garden); // ✅ 안에서 밖은 보여요: '마당의 꽃' 출력
  console.log(desk); // ✅ 내 방 물건은 당연히 보여요: '책상 위의 노트북' 출력
}

myHouse();

console.log(garden); // ✅ 밖에서도 밖은 보여요: '마당의 꽃' 출력
// console.log(desk)  // ❌ 밖에서 안은 안 보여요: ReferenceError 발생!
```

### 스코프 체인

변수를 찾을 때, 현재 구역에 없으면 **점점 더 바깥 구역으로 나가면서** 찾습니다.
하지만 바깥에서 안쪽으로 들어오며 찾을 수는 없습니다.

```jsx
let garden = '마당의 꽃'; // 전역 스코프

function myHouse() {
  let livingRoom = '거실의 소파'; // 함수 스코프

  function myRoom() {
    let desk = '책상 위의 노트북'; // 더 깊은 함수 스코프

    // 안쪽에서는 바깥쪽 모든 변수 접근 가능 (체이닝)
    console.log(garden); // ✅ '마당의 꽃'
    console.log(livingRoom); // ✅ '거실의 소파'
    console.log(desk); // ✅ '책상 위의 노트북'
  }

  myRoom();

  console.log(garden); // ✅ '마당의 꽃'
  console.log(livingRoom); // ✅ '거실의 소파'
  // console.log(desk)     // ❌ ReferenceError! 오류 발생 시, 실행 중단됨!
}

myHouse();

console.log(garden); // ✅ '마당의 꽃'
// console.log(livingRoom)  // ❌ ReferenceError! 오류 발생 시, 실행 중단됨!
// console.log(desk)        // ❌ ReferenceError! 오류 발생 시, 실행 중단됨!
```

---

# 일시적 사각지대 (TDZ)

JavaScript의 일시적 사각지대(TDZ)는 변수가 선언되었지만,
아직 초기화되지 않아 사용할 수 없는 "금지된 구역"을 말합니다.

이는 `let`, `const`를 사용해 안전한 코드를 짜기 위한 핵심 장치입니다.

JavaScript 세계에서 변수를 만드는 과정은 마치 건물을 짓는 것과 같습니다.

1. 변수 **선언** (declaration) : "여기에 건물을 짓겠다." 결정
2. 변수 **초기화** (initialization) : 실제로 건물을 완공해 입주 가능한 상태로 만들기

### 안전 펜스가 없는 공사장

`var` 공법은 지어지는 변수 관리가 허술합니다.

건물을 짓겠다고 땅만 파놓은 상태(선언)에서도 사람들이 들어와 돌아다닐 수 있게 허용해버립니다.

사람들이 "아직 건물이 없네요?" 라고 물으면,
인부들이 "일단 `undefined` 텐트라도 쳐놨으니 거기 계세요."라고 답하는 꼴입니다.

```jsx
// 위험한 var 방식
console.log('건물 상태:', building); // undefined (텐트라도 쳐놨으니 들어가실래요?)

var building = '완공된 아파트';

console.log('건물 상태:', building); // "완공된 아파트"
```

`var`는 선언과 동시에 `undefined`로 초기화되어, 실제 값이 할당되기 전에도 접근할 수 있습니다.
이는 예상치 못한 버그(오류)를 만들 수 있습니다.

### TDZ라는 안전 펜스

반면, `let`과 `const`는 매우 엄격합니다.

건물이 완공(초기화)되기 전까지는 공사장 주변에 **두꺼운 안전 펜스(TDZ)**를 쳐놓습니다.
펜스를 넘으려 하면 보안 요원(JavaScript 엔진)이 오류를 던집니다.

**"ReferenceError! 아직 건물이 완공되지 않았으니 접근할 수 없습니다!"**

결과적으로 개발자가 실수로 변수를 미리 쓰는 일을 방지할 수 있어 훨씬 안전한 코드를 짤 수 있습니다.

```jsx
// 안전한 let/const 방식

// --- TDZ 시작 ---
console.log('건물 상태:', building);
// 🚨 ReferenceError: Cannot access 'building' before initialization
// "아직 건물이 완공되지 않았으니 접근할 수 없습니다!" (아직 초기화되지 않음)
// --- TDZ 끝 ---

let building = '완공된 아파트'; // 초기화 완료! 이제부터 사용 가능 (펜스가 걷힘)

console.log('건물 상태:', building); // "완공된 아파트"
```

### TDZ는 왜 생길까?

JavaScript 엔진이 코드를 읽을 때, 변수들은 다음과 같은 단계를 거칩니다.

1. **선언 단계 (Declaration)**
   "여기에 변수를 만들거야."라고 등록하는 단계
2. **초기화 단계 (Initialization)**
   메모리에 공간을 확보하고 값을 넣는 단계 (값이 없으면 `undefined`라도 넣음)

| **구분**      | **과정**                            | **결과**                                  |
| ------------- | ----------------------------------- | ----------------------------------------- |
| `var`         | 선언과 초기화가 **동시에** 일어남   | 선언 전 호출 시, `undefined` (위험)       |
| `let / const` | 선언과 초기화가 **분리**되어 일어남 | 선언 후 초기화 전까지 **TDZ** 형성 (안전) |

### TDZ가 주는 교훈

TDZ는 JavaScript가 우리를 괴롭히려고 만든 것이 아닙니다.

**"변수를 사용하기 전에 반드시 먼저 선언하고 값을 넣어라."**는 상식적이고 안전한 규칙을 강제하는 장치입니다.

따라서 코드를 짤 때는 **항상 변수 선언을 코드의 맨 위쪽(상단)에 배치하는 습관**을 가지는 것이 좋습니다.

---

# 호이스팅 (Hoisting)

`function` 키워드를 사용해 함수를 선언하면 **현재 코드 영역(Scope)의 맨 위로 끌어올려집니다**.

이를 통해 함수를 파일 끝에 몰아넣어도 상단에서 문제없이 실행할 수 있습니다.

이와 같이 끌어올려지는 현상을 "[호이스팅(Hoisting)](https://developer.mozilla.org/ko/docs/Glossary/Hoisting)"이라 부릅니다.

쉽게 말해 "모든 선언을 파일 맨 위로 옮겨서 먼저 기억한다."고 이해하면 됩니다.

### 함수 선언과 호이스팅

JavaScript 엔진은 코드를 실행하기 전, 전체를 한 번 훑으며 선언된 함수들을 찾아 메모리에 미리 등록합니다. 덕분에 함수가 실제 코드 위치보다 아래에 있더라도, 마치 맨 위에 있는 것처럼 호출할 수 있습니다.

**사용자가 작성한 코드**

```jsx
sayHello(); // ✅ 호이스팅 덕분에 정상 실행

function sayHello() {
  console.log('안녕! JavaScript 🌼');
}
```

**JavaScript 엔진이 인식하는 순서**

```jsx
// 1. 함수 선언을 먼저 메모리에 등록 (끌어올림)
**function sayHello() {
  console.log('안녕! JavaScript 🌼')
}**

// 2. 코드 실행
sayHello()
```

이 기능 덕에 중요한 로직을 상단에 적고, 구체적인 함수 구현부는
파일 하단에 정리할 수 있어 코드가 깔끔해집니다.

```jsx
// 코드 흐름 먼저 작성 (읽기 쉬움)
startGame();
movePlayer();
endGame();

// 함수 구현은 아래에 배치 (복잡한 내용은 뒤로)
function startGame() {
  // ...
}

function movePlayer() {
  // ...
}

function endGame() {
  // ...
}
```

### **변수 호이스팅**

앞서 살펴본 '함수 선언'은 선언부 전체가 위로 끌어올려져서 아주 편리하게 사용할 수 있었습니다.

그렇다면 **변수**는 어떨까요? 변수도 함수 선언처럼 위로 올라가긴 하지만,
어떤 키워드(`var`, `let`, `const`)를 쓰느냐에 따라 결과가 완전히 다릅니다.

**var의 호이스팅 (일단 빈 상자라도 두기)**

`var`로 선언된 변수는 맨 위로 끌어올려질 때, 임시 값으로 초기화됩니다. 즉, 선언하기도 전에 부르면 에러가 나는 대신 "아직 값은 없지만, 변수는 있다(`undefined`)"라고 대답합니다.

```jsx
console.log(language); // undefined (에러는 안 나지만, 빈 껍데기만 있음)

var language = 'JavaScript';

console.log(language); // "JavaScript" (이제야 값이 들어감)
```

**let과 const의 호이스팅 (준비 안 됐으면 접근 금지!)**

많은 이들이 "`let`과 `const`는 호이스팅이 안 된다"고 오해하지만, **사실 호이스팅이 됩니다.**
다만, var와 달리 **값을 넣기 전까지는 접근할 수 없도록 막아둡니다**.

이 구간이 앞서 배운 **TDZ**(일시적 사각지대)입니다.

```jsx
console.log(topic); // 🚨 ReferenceError! (호이스팅은 됐지만, 펜스에 막힘)

let topic = '호이스팅';
```

**한눈에 보는 호이스팅 차이**

결국 핵심은 "호이스팅이 되느냐"가 아니라, "**끌어올려진 직후에 바로 쓸 수 있느냐**"입니다.

| **구분**    | **호이스팅 여부** | **초기화 방식**           | **결과**                         |
| ----------- | ----------------- | ------------------------- | -------------------------------- |
| 함수 선언문 | O                 | 함수 전체를 통째로 등록   | **사용 가능** (완벽함)           |
| var         | O                 | `undefined`로 임시 초기화 | **사용 가능** (하지만 값이 없음) |
| let / const | O                 | 초기화 안 함 (TDZ)        | **에러 발생** (안전함)           |

### 함수 표현식과 호이스팅

주의해야 할 점은 **모든 함수가 다 바로 실행 가능한 것은 아니라는 점**입니다.

변수에 함수를 담는 **함수 표현식**은 '함수'가 아니라 **'변수'의 호이스팅 규칙**을 따르기 때문입니다.

특히 `let`이나 `const`를 사용한 함수 표현식은 변수처럼 **일시적 사각지대(TDZ)**에 영향을 받습니다.

**오류가 발생하는 코드**

```jsx
sayHello(); // 🚨 ReferenceError: Cannot access 'sayHello' before initialization

let sayHello = function () {
  console.log('안녕! JavaScript 🌼');
};
```

**JavaScript 엔진에서 처리된 코드**

```jsx
// 1. [선언 단계] 엔진이 변수 이름을 메모리에 등록하지만,
// 아직 초기화되지 않아 'TDZ(펜스)'가 쳐진 상태입니다.
**let sayHello**

// 2. [실행 단계] 펜스(TDZ)가 있는 상태에서 함수를 부르려 합니다.
sayHello() // 🚨 ReferenceError (보안 요원이 접근 차단!)

// 3. [할당 단계] 펜스가 걷히고 실제 함수 내용이 담깁니다.
sayHello = function() {
  console.log('안녕! JavaScript 🌼')
}
```

**작동 흐름 분석**

1. **[선언 단계]** 
   엔진이 `sayHello`라는 이름을 알게 되지만, 아직 내용이 없으므로 TDZ(펜스)를 쳐둡니다.
2. **[실행 단계]** 
   `sayHello()`를 호출하려 하지만, 펜스가 쳐져 있어 접근이 차단됩니다.
3. **[할당 단계]** 
   코드가 `let sayHello = ...` 줄에 도달해서야 펜스가 걷히고 함수가 할당됩니다.

따라서 함수 표현식을 쓸 때는 반드시 **"먼저 정의하고 나중에 호출"**해야 합니다.

---

# 요약

- **스코프 (Scope)**
  - 변수가 활동할 수 있는 **유효 범위**입니다.
  - "안에서는 밖이 보이지만, 밖에서는 안이 보이지 않는다"는 규칙을 기억하세요.
- **TDZ (일시적 사각지대)**
  - 변수 선언 후, 초기화되기 전까지의 **사용 금지 구역**입니다.
  - `let`과 `const`는 이 구역에서 철저히 보호받아 안전합니다.
- **호이스팅 (Hoisting)**
  - 변수나 함수 선언을 **최상단으로 끌어올려 먼저 기억하는 현상**입니다.
  - 함수 선언문은 바로 쓸 수 있지만, `let/const`로 만든 함수 표현식은 선언 전에는 쓸 수 없습니다.
- **안전 수칙**
  - `var` 대신 **`let`, `const`를 사용**하세요.
  - **변수와 함수 선언**은 항상 **코드의 상단**에 작성하세요.

## Excution context

스코프, TDZ, 호이스팅이 작동되는 진짜 무대

전역 실행 컨텍스트
함수 실행 컨텍스트
전역 실행 컨텍스트는 코드 실행 전에 변수와 함수 선언을 수집해 환경을 구성하고, 스코프를 설정한 뒤, 실행 단계에서 실제 값들을 할당하며 코드를 실행합니다.

오픈 (브라우저가 자바스크립트 읽음)
전역 실행 컨텍스트 생성
window, globalThis,this키워드 연결

전역 객체 생성

1. 이름표 준비
2. 창고 출입 통제
3. 택배 목록 기록
4. 물건을 박스에 넣음

실행 컨택스트

1. 물건 주문 (함수 호출)
2. 배송을 위한 작업대 준비 (함수 실행 컨텍스트 생성)
3. 작업대에 박스를 준비하고 이름표를 붙인다 (호이스팅) + 출입 통제(tdz)
4. 작업자가 택배에 물건을 넣습니다. (변수에 값 넣기)
5. 손님이 물건을 받으면 작업대를 정리합니다 (메모리 정리)
